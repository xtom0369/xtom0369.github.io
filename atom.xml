<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xtom&#39;s blog</title>
  
  
  <link href="https://xtom0369.github.io/atom.xml" rel="self"/>
  
  <link href="https://xtom0369.github.io/"/>
  <updated>2022-01-25T14:11:04.041Z</updated>
  <id>https://xtom0369.github.io/</id>
  
  <author>
    <name>xtom</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xasset pro的使用体验</title>
    <link href="https://xtom0369.github.io/2022/01/20/xasset%20pro%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>https://xtom0369.github.io/2022/01/20/xasset%20pro%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</id>
    <published>2022-01-20T13:36:27.000Z</published>
    <updated>2022-01-25T14:11:04.041Z</updated>
    
    <content type="html"><![CDATA[<p>最近把项目的资源层换成了<a href="https://www.xasset.pro/">xasset团队版</a>，有收获，也有低于预期的地方，下面我会把他的核心功能一一列举，并详细描述体验和遇到的问题。总的来说瑕不掩瑜，作为一个3000块的产品，还是值得的，产品确实有打磨过的痕迹，代码多次精简之后，阅读性和可维护性较强。下面我重点写他的使用体验，操作层面直接看文档或者看源码即可。文章比较长，但包含了实战过程中的经验，希望大家看完应该可以避开一些坑。</p><span id="more"></span><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a><font color="#64EBC1">目的</font></h2><p>上一篇<a href="https://zhuanlan.zhihu.com/p/458672730">大地图分块加载</a>的文章里有提到，当时我们有了一个<strong>流畅分帧加载</strong>的需求，我们之前的项目主要是分量加载，比如最多同时加载10的资源，这种设计的问题我在上一篇文章也提到了，加载10个10M的资源和10个10k的资源是不一样的事情，没办法实现平滑加载，而分帧加载是xasset pro的宣传点之一。</p><p>其次是分包和边玩边下的功能，这个功能只是用demo简单玩了下和粗略过了一下源码，还没深入使用，以后用了再回来补充吧。但是和专门做这块的快乐变化公司的边玩边下（用过），价格相比绝对是碾压，其次那种全套源码在手做扩展做定制化真的很爽，特别是代码可阅读性较高的时候。</p><p>所以综合考虑下购买了团队版服务。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><font color="#64EBC1">核心功能</font></h2><p>这是官方的宣传卖点</p><p><img src="/2022/01/20/xasset%20pro%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/%E4%BC%98%E7%82%B91.png" alt="优点1"></p><p><img src="/2022/01/20/xasset%20pro%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/%E4%BC%98%E7%82%B92.png" alt="优点2"></p><p>以下说下用下来之后感受比较深的点</p><ul><li><strong>分帧加载</strong></li></ul><p>为什么把分帧放第一位，因为他确实给了我很大的启发，核心代码我在<a href="https://zhuanlan.zhihu.com/p/458672730">分块加载</a>的文章里有贴，非常简单的几行代码，把分帧加载的思路展现得淋漓尽致。这种分帧的思路不仅可以用在资源层的加载，业务层同样可以使用，是一种特别有效的优化手段。</p><p>资源的加载流程一般包括<strong>下载（针对边玩边下） -&gt; 加载 -&gt; 实例化 -&gt; 加载回调</strong>，这其中加载和加载回调是最不可控的，特别是加载回调，是接口调用者的代码，如果把这些流程放在一帧去执行就容易产生尖峰。</p><p>阅读源码可知，满载判断的API为<strong>Updater.busy</strong>，阈值为10ms，在</p><ol><li>下载（Download.UpdateAll）</li><li>加载（Loadable.UpdateLoadingAndUnused）</li><li>卸载（Loadable.UpdateLoadingAndUnused）</li><li>实例化（InstantiateObject.Update）</li></ol><p>都做了分帧处理。</p><p><strong>当然当前的分帧方案我觉得还有改进空间。</strong></p><ol><li>抛开单个资源过大的情况，分帧后仍有可能造成尖峰。</li></ol><p>资源层用Updater.Update()来做总更新驱动，采用了多个管理器分别管理多种行为的设计，比如</p><p>1）下载管理器（Download）管理所有<strong>下载</strong><br>2）加载器（Loadable，其实也是资源基类）管理所有的<strong>加载和卸载</strong>行为<br>3）实例化器（InstantiateObject）管理所有的<strong>实例化</strong>操作</p><p>Updater.Update代码如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    realtimeSinceUpdateStartup = Time.realtimeSinceStartup;</span><br><span class="line">    ...</span><br><span class="line">    Loadable.UpdateLoadingAndUnused();</span><br><span class="line">    Operation.UpdateAll(); <span class="comment">// InstantiateObject是Operation的派生类</span></span><br><span class="line">    Download.UpdateAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满载busy的判断分别在各个管理器的更新方法中，这样一来当<strong>加载/实例化/下载</strong>同时满载时，其实分帧加载的峰值是可以达到30ms+，且加载回调没有纳入分帧满载的判断中，也是一个不可控因素。</p><p>我更偏向于把单个资源加载的所有流程当做统筹，加载 -&gt; 实例化 -&gt; 加载回调，单个步骤判断到满载就跳出，下一个循环从上次退出阶段往下走，从而降低三个阶段同时达到峰值的风险。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; _reqQueue = <span class="keyword">new</span> Queue&lt;T&gt;();</span><br><span class="line"><span class="built_in">float</span> _lastUpdateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 是否满载</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="built_in">bool</span> busy =&gt; Time.realtimeSinceStartup - _lastUpdateTime &gt;= <span class="number">0.005f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 每帧更新</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _lastUpdateTime = Time.realtimeSinceStartup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_reqQueue.Count &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> req = _reqQueue.Dequeue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载和实例化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (busy) <span class="comment">// 超过实例化的时间则分帧处理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>没有设计分帧加载的开关</li></ol><p>Loading的时候都是不做分帧的，性能尽可能吃满。</p><ul><li><strong>资源加载封装</strong></li></ul><p>之前我们项目中这块其实没有特地封装过，所以导致工程后续出现了很多if代码，用于区分AB和非AB模式，后面加上了状态同步要共用部分客户端的代码，好家伙，大家一顿ctl+c ctl+v直接起飞。为了兼容AB和非AB两种模式，xasset在构建ab时同时生成了一个Manifest，用于记录每个bundle的信息，运行时利用Manifest生成asset到bundle的映射。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单个bundle的信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ManifestBundle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; assets;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 每个build的中生成的所有bundle的信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Manifest</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">ManifestBundle</span>&gt; bundles</span> = <span class="keyword">new</span> List&lt;ManifestBundle&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">ManifestBundle</span>&gt; nameWithBundles</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, ManifestBundle&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加载时构建asset到bundle的引用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        nameWithBundles.Clear();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> bundle <span class="keyword">in</span> bundles)</span><br><span class="line">        &#123;</span><br><span class="line">            nameWithBundles[bundle.name] = bundle;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> asset <span class="keyword">in</span> bundle.assets)</span><br><span class="line">                nameWithBundles[asset] = bundle;</span><br><span class="line">        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样做有两个非常大的好处</p><ol><li>方便代码统一，不需要区分AB与非AB的方式来加载资源</li><li>开发者加载时不需要关心资源从属于哪个bundle中。<strong>注意，是加载时不需要关心，构建AB时是需要关心的。</strong> 比如同个场景中的资源如果分散在太多ab中会增加场景加载时的IO。这个优点对后续优化资源大小，或者优化AB构建规则以提高加载速度有很大的帮助。</li></ol><p><strong>但是，这种设计不兼容一种情况，就是直接拿bundle去取出所有的资源的时候</strong>，当然官方也提供了接口去获取bundle（Versions.GetBundle），就是需要区分代码。</p><ul><li><strong>分布式增量打包</strong></li></ul><p><a href="https://www.xasset.pro/docs/nocentral">分布式增量打包</a>也是xasset的卖点之一，这里需要先了解两个个概念，<strong>Build和Group</strong>，Build是构建分组，Group是单个构建规则，Build包含了一个或多个Group。</p><p><img src="/2022/01/20/xasset%20pro%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/Build%E5%92%8CGroup.png" alt="Build和Group"></p><p>如图，我们定义了一个bytes的Build，是一个专门用来放二进制的分组，其中包含了配置表二进制config group和状态机二进制fsm group，当我们想更新了配置表或者状态机的二进制时，可点击底下的【Build Bundles】菜单进行单独构建，而不用对整个工程进行增量构建。</p><p>这是他的优点，下面说下我们在接入过程中的感受和遇到的问题。</p><ol><li>实用场景不多</li></ol><p>这个功能接入进来最大的好处就是遇到非AB模式没问题但AB模式有问题时，可以快速调试，比如配置、状态机、ui等出现问题时，可以快速修改和构建，然后测试。</p><p>其他时候其实很少用到这个功能，一般打包都是全部增量构建。</p><p>然而这个功能对于那些开发也用ab的团队就是救命的功能了。（但是开发用ab本身也是有问题的，我们上上个项目就在这上面吃过亏，效率极其低下）</p><ol start="2"><li>不完整的“分布式”</li></ol><p>我理解的分布式其实是并行构建，但是当前其实还是串行的，因为受限unity的构建接口BuildPipeline.BuildAssetBundles，只能挨个构建Build。Unity提供了一个可编程构建的package <a href="https://docs.unity3d.com/Packages/com.unity.scriptablebuildpipeline@1.19/manual/index.html">Scriptable Build Pipeline</a>，貌似有并行功能（没考察过），如果能做到就非常厉害了，毕竟我们现在用12核24线程构建时的机器性能是吃不满的。</p><ol start="3"><li>“有要求”的分组</li></ol><p>我们最开始计划是将英雄、怪物、场景、特效、ui等全部分拆到各个Build中，按需构建之余也方便维护。然而这样做有个前提是，依赖的资源和shader必须也是按照这个分类来的，资源我们一直都有分，但shader是共用的，那就势必会导致shader冗余，考虑了实用场景不多，加上shader收集的变体也需要分拆的问题，最终我们选择了将依赖的shader放同一个build，只是做了简单分类，如上面Build和Group的图所示。</p><ol start="4"><li>配置设计不完善</li></ol><p>1）Group的Target不能将Package中的文件夹拖进去设置</p><p>这种情况下只能是手动填一下配置了，或者写临时代码塞个Group进去。</p><p>2）Target不属于版本控制时无法</p><p><img src="/2022/01/20/xasset%20pro%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/Group%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="Group的序列化"></p><p>我们的配置表有个导出成二进制的过程，但是导出的二进制是不会上传到svn进行版本维护，而Target记录的是文件夹的fileID和guid，不上传则每个人本地fileID和guid不一致。我们的解决方法是加多了字段记录路径</p><ul><li><strong>资源加密</strong></li></ul><p><a href="https://www.xasset.pro/docs/encryption">xasset的资源加密</a></p><p>翻了一下这块的代码没有开放到免费版，就不写太多了，可以参考文档。</p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a><font color="#64EBC1">其他功能</font></h2><ul><li><strong><a href="https://www.xasset.pro/docs/splitbuild">分包功能</a></strong></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><font color="#64EBC1">其他问题</font></h2><ul><li><strong>只负责实例化，不维护实例化出来的对象</strong></li></ul><p>这个不算是缺陷，只是不看源码容易有误区。xasset用InstantiateObject.InstantiateAsync的方法实例化模板，但实例化出来的对象需要做什么，需不需要做对象池，需要开发者自己再做封装。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">InstantiateObject</span> : <span class="title">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Asset _asset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 加载模板</span></span><br><span class="line">        _asset = Asset.LoadAsync(_path, <span class="keyword">typeof</span>(GameObject));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InstantiateObject <span class="title">InstantiateAsync</span>(<span class="params"><span class="built_in">string</span> assetPath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> operation = <span class="keyword">new</span> InstantiateObject</span><br><span class="line">        &#123;</span><br><span class="line">            _path = assetPath</span><br><span class="line">        &#125;;</span><br><span class="line">        operation.Start();</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 实例化模板</span></span><br><span class="line">        result = Object.Instantiate(_asset.asset <span class="keyword">as</span> GameObject);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>InstantiateObject的Update在调用前也是做了满载busy判断的，即分帧实例化</strong></p><h2 id="船新版本"><a href="#船新版本" class="headerlink" title="船新版本"></a><font color="#64EBC1">船新版本</font></h2><p>作者力推的2022版本据说出了很多新功能</p><p><a href="2022%E7%89%88%E6%9C%AC.png">2022版本</a></p><p>如果感兴趣的人多的话我再针对性试用一下~</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><font color="#64EBC1">结语</font></h2><p>我这样的“鸡蛋里挑骨头”总是很简单的事情，难的是xasset这种从0到1，总结开发经验，梳理开发需求，从而实现一个相对通用的模块。特别是在unity这种只提供基础底层和一堆未经过商业化考验的package和插件的引擎下，各个模块的进一步封装的需求还是很强烈的，对于大部分中小型游戏公司来说尤其如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近把项目的资源层换成了&lt;a href=&quot;https://www.xasset.pro/&quot;&gt;xasset团队版&lt;/a&gt;，有收获，也有低于预期的地方，下面我会把他的核心功能一一列举，并详细描述体验和遇到的问题。总的来说瑕不掩瑜，作为一个3000块的产品，还是值得的，产品确实有打磨过的痕迹，代码多次精简之后，阅读性和可维护性较强。下面我重点写他的使用体验，操作层面直接看文档或者看源码即可。文章比较长，但包含了实战过程中的经验，希望大家看完应该可以避开一些坑。&lt;/p&gt;</summary>
    
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/categories/Unity/"/>
    
    <category term="资源加载" scheme="https://xtom0369.github.io/categories/Unity/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/tags/Unity/"/>
    
    <category term="资源加载" scheme="https://xtom0369.github.io/tags/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="分帧加载" scheme="https://xtom0369.github.io/tags/%E5%88%86%E5%B8%A7%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="xasset" scheme="https://xtom0369.github.io/tags/xasset/"/>
    
  </entry>
  
  <entry>
    <title>大地图的分块加载</title>
    <link href="https://xtom0369.github.io/2022/01/16/%E5%A4%A7%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%88%86%E5%9D%97%E5%8A%A0%E8%BD%BD/"/>
    <id>https://xtom0369.github.io/2022/01/16/%E5%A4%A7%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%88%86%E5%9D%97%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-01-16T06:37:38.000Z</published>
    <updated>2022-01-17T14:13:19.734Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间在项目上新增了大地图的分块加载的机制，踩了很多坑，记录一下经历，分享之余，也希望能和大家共同探讨优化的方向。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a><font color="#64EBC1">目的</font></h2><p>项目的框架用的是上一个项目的小地图实时竞技的框架，面对新项目的中等偏大的地图存在明显得不适应，包括loading过慢，运行时帧数过低等各种问题，需要引入新的地图加载策略来改善加载与运行时效率的问题。</p><span id="more"></span><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a><font color="#64EBC1">方案</font></h2><p>定方案时参考了<a href="https://assetstore.unity.com/packages/tools/terrain/sectr-complete-2019-144433">SECTR COMPLETE</a>插件，也参考了网上的一些资料，SECTR COMPLETE插件主要还是针对地形，包括提供了地形分割工具以及依据分割后的分块加载案例，但是我们的场景是由模型搭建起来的而不是地形，加上我们的场景不仅是横向扩展，也是纵向扩展，有多层楼，所以不太适用。</p><p>所以比较后还是选用了一个比较傻瓜化且容易实现的方案，即<strong>程序实现分块加载和配置机制 + 美术手动进行场景分割 + 策划手动配置加载卸载时机</strong>的方式，这种方案虽然看起来比较low，但胜在实现难度较低，可操作性强。</p><h3 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h3><p>美术主要是将场景由单个场景分拆为多个场景，注意<strong>场景分布相对均匀且不穿帮</strong>，程序需要提供一个编辑器用于将分块场景进行加载和卸载，方便美术编辑。</p><h3 id="策划"><a href="#策划" class="headerlink" title="策划"></a>策划</h3><p>策划需要配置每块场景的加载和卸载时机，这里有两个需要注意的点</p><ul><li><strong>提前制定可用于加载或卸载的时机</strong></li></ul><p>加载时对CPU的占用会变高，需要程序提前和策划协商好加载时机，比如CG和视频播放，或者走过某些只需要玩家纯移动的过场等CPU相对空闲的时候</p><ul><li><strong>添加保底</strong></li></ul><p>我们在加载过程中在底层和应用层都用了分帧加载，存在走到某一块时资源还未准备好的情况，需要提供可配置的保底机制，最粗暴的是打开loading之类的，当然一般不会触发。注意开启loading时关闭分帧加载，将加载速度拉满。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序的工作重点在于，如何保证实现<font color="#F46224"><strong>丝滑</strong></font>的分块加载和卸载。</p><p>围绕这个重点，我们重点做了以下件事情</p><ul><li><strong>资源层的分帧加载</strong></li></ul><p>这是最为核心的一部分。因为如果不能实现丝滑的分帧加载，那对于策划来说不如把他们丢回loading去做，虽然慢，但是至少不影响过程中的体验。</p><p>资源层的对象池这些就不赘述了，几乎是每个项目必备。在对象池的基础上，资源层的分帧加载集中在两块，一是<font color="#F46224"><strong>加载</strong></font>，二是<font color="#F46224"><strong>实例化</strong></font>。分帧加载的思路是，所有的加载请求用加载队列进行维护，每帧分配固定的时间进行加载和实例化，比如10ms，超过了则放到下一帧进行处理，核心代码也非常简单</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; _reqQueue = <span class="keyword">new</span> Queue&lt;T&gt;();</span><br><span class="line"><span class="built_in">float</span> _lastUpdateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 是否满载</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="built_in">bool</span> busy =&gt; Time.realtimeSinceStartup - _lastUpdateTime &gt;= <span class="number">0.005f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 每帧更新</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _lastUpdateTime = Time.realtimeSinceStartup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_reqQueue.Count &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> req = _reqQueue.Dequeue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载和实例化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (busy) <span class="comment">// 超过实例化的时间则分帧处理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的算法虽然可以实现基本的分帧需求，但问题也很明显：</p><p>1）单个资源的加载和实例化的耗时可能仍较大时会产生尖峰</p><p>2）单个资源的加载耗时已经较大时会产生尖峰</p><p>第一个问题比较好解决，可以进一步优化，为单个资源的请求维护一个状态，未加载/加载/实例化/已加载，在加载与实例化之前加多一步满载检测，满载则跳出循环，下一帧再继续处理</p><p>第二个问题其实是第一个问题的恶化结果，常见于场景加载，我们的处理方式是将场景资源分块导出成预制体，运行时再分块加载。这里有一个需要注意的点，<font color="#FF0000"><strong>需要确保场景在分拆为预制体后烘焙结果不受影响</strong></font>。我们用的是<a href="https://assetstore.unity.com/packages/tools/level-design/bakery-gpu-lightmapper-122218?locale=zh-CN">Bakery</a>来做场景烘焙，烘焙后的结果可能存在对GameObject或Component的实例依赖（如下图），这种情况下做分拆会导致烘焙结果失效，这种情况的一个解决方法是将烘焙后的结果和依赖的实例打成一个预设。</p><p><img src="/2022/01/16/%E5%A4%A7%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%88%86%E5%9D%97%E5%8A%A0%E8%BD%BD/1.png" alt="1"></p><ul><li><strong>业务层场景配置的彻底分块</strong></li></ul><p>战斗场景中除了有基本的场景资源外，经常伴随着刷怪，刷关卡物件等场景配置类需求，需要将对应的配置资源进行彻底分块，比如怪物A和物件A隶属于分块A等，加载分块A时将怪物A和物件A进行预加载，将配置资源的彻底分块有利于减少内存和CPU的浪费。</p><ul><li><strong>业务层的分帧加载</strong></li></ul><p>业务层除了资源的加载外，各个项目可能还有其他许多需要处理的逻辑，比如我们项目中使用了帧同步，需要创建相应的逻辑层和显示层，我们还将部分较为耗时的Component在导出资源时进行隐藏，加载后进行分帧激活，等等的逻辑，也需要做分帧处理。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a><font color="#64EBC1">其他优化</font></h2><ul><li>组件分帧加载</li></ul><p>部分Component的启动生命周期耗时较高但激活顺序对结果没有影响时，可以将Component或GameObject在场景加载后，进行延迟分帧激活</p><h4 id="这就是我们中等地图的分块加载思路，欢迎指点和探讨"><a href="#这就是我们中等地图的分块加载思路，欢迎指点和探讨" class="headerlink" title="这就是我们中等地图的分块加载思路，欢迎指点和探讨~"></a>这就是我们中等地图的分块加载思路，欢迎指点和探讨~</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一段时间在项目上新增了大地图的分块加载的机制，踩了很多坑，记录一下经历，分享之余，也希望能和大家共同探讨优化的方向。&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#64EBC1&quot;&gt;目的&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;项目的框架用的是上一个项目的小地图实时竞技的框架，面对新项目的中等偏大的地图存在明显得不适应，包括loading过慢，运行时帧数过低等各种问题，需要引入新的地图加载策略来改善加载与运行时效率的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/categories/Unity/"/>
    
    <category term="资源加载" scheme="https://xtom0369.github.io/categories/Unity/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/tags/Unity/"/>
    
    <category term="资源加载" scheme="https://xtom0369.github.io/tags/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="大世界" scheme="https://xtom0369.github.io/tags/%E5%A4%A7%E4%B8%96%E7%95%8C/"/>
    
    <category term="分帧加载" scheme="https://xtom0369.github.io/tags/%E5%88%86%E5%B8%A7%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>游戏物理（一）基本概念</title>
    <link href="https://xtom0369.github.io/2021/12/08/%E6%B8%B8%E6%88%8F%E7%89%A9%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://xtom0369.github.io/2021/12/08/%E6%B8%B8%E6%88%8F%E7%89%A9%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2021-12-08T13:38:36.000Z</published>
    <updated>2021-12-09T14:05:41.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#64EBC1">前言</font></h2><p><strong>只有牢固的基础才能攀登更高的山峰。</strong></p><h2 id="定律"><a href="#定律" class="headerlink" title="定律"></a><font color="#64EBC1">定律</font></h2><h3 id="牛顿运动定律"><a href="#牛顿运动定律" class="headerlink" title="牛顿运动定律"></a>牛顿运动定律</h3><ol><li><p>每个物体都保持<strong>静止或者匀速直线运动</strong>的状态，除非有外力作用于它迫使它改变状态。</p></li><li><p>运动的变化正比于外力，变化的方向沿外力作用的直线方向。</p></li><li><p>每一个作用都有一个相等的反作用，两个物体的相互作用总是相等的。</p></li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font color="#64EBC1">基本概念</font></h2><ul><li><h3 id="右手坐标系"><a href="#右手坐标系" class="headerlink" title="右手坐标系"></a>右手坐标系</h3><p>二维的坐标系统中，逆时针旋转为正方向</p></li><li></li></ul><h2 id="通用符号"><a href="#通用符号" class="headerlink" title="通用符号"></a><font color="#64EBC1">通用符号</font></h2><table><thead><tr><th>物理量</th><th>符号</th><th>量纲</th></tr></thead><tbody><tr><td>线性加速度</td><td>A</td><td>L/T^2^</td></tr><tr><td>单元格</td><td>单元格</td><td>单元格</td></tr></tbody></table><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a><font color="#64EBC1">公式</font></h2><p>$F = ma$</p><img src="/2021/12/08/%E6%B8%B8%E6%88%8F%E7%89%A9%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/file.png" width="100" height="35" alt="图片名称" align="left">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#64EBC1&quot;&gt;前言&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;只有牢固的基础才能攀登更高的山峰。&lt;/strong&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="physics" scheme="https://xtom0369.github.io/categories/physics/"/>
    
    
    <category term="physics" scheme="https://xtom0369.github.io/tags/physics/"/>
    
  </entry>
  
  <entry>
    <title>Unity的Collider参数需要注意的点</title>
    <link href="https://xtom0369.github.io/2021/11/20/Unity%E7%9A%84Collider%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>https://xtom0369.github.io/2021/11/20/Unity%E7%9A%84Collider%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</id>
    <published>2021-11-20T15:42:16.000Z</published>
    <updated>2022-01-16T05:43:56.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#64EBC1">前言</font></h2><p>问题的起因是项目中物理引擎的效果和运行时不一致，出现了一些虚空阻挡，或者碰撞效果异常，最后查到是对Collider组件中center等参数理解有偏差，<font color="#F46224">部分参数的配置需要叠加GameObject的rotation和scale的效果才是最终的结果</font>。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a><font color="#64EBC1">详解</font></h2><p>由于物理引擎用的是Bullet，以BoxCollider为例，</p><p><img src="/2021/11/20/Unity%E7%9A%84Collider%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/BoxCollider.png" alt="BoxCollider"></p><p>Bullet底层只认transform和boxHalfExtents（boxHalfExtents为size的一半），并没有center的概念，所以需要把center叠加到position上，以及把size换算为boxHalfExtents后传递给Bullet。</p><p>这里有个需要注意的点是，center和size都是给予BoxCollider所在的GameObject的局部设置，所以center和size的换算需要叠加GameObject的rotation以及scale，代码如下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> transform.position叠加了center后的世界坐标</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> Vector3 worldPosition =&gt; transform.position + Vector3.Scale(transform.rotation * center, transform.lossyScale);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Vector3 boxHalfExtents =&gt; Vector3.Scale(transform.rotation * size / <span class="number">2</span>, transform.lossyScale);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#64EBC1&quot;&gt;前言&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;问题的起因是项目中物理引擎的效果和运行时不一致，出现了一些虚空阻挡，或者碰撞效果异</summary>
      
    
    
    
    <category term="Physics" scheme="https://xtom0369.github.io/categories/Physics/"/>
    
    <category term="Unity" scheme="https://xtom0369.github.io/categories/Physics/Unity/"/>
    
    <category term="Bullet Physics" scheme="https://xtom0369.github.io/categories/Physics/Unity/Bullet-Physics/"/>
    
    
    <category term="Bullet Physics" scheme="https://xtom0369.github.io/tags/Bullet-Physics/"/>
    
    <category term="Physics" scheme="https://xtom0369.github.io/tags/Physics/"/>
    
    <category term="Unity" scheme="https://xtom0369.github.io/tags/Unity/"/>
    
    <category term="Collider" scheme="https://xtom0369.github.io/tags/Collider/"/>
    
  </entry>
  
  <entry>
    <title>三大物理引擎之Bullet</title>
    <link href="https://xtom0369.github.io/2021/10/28/%E4%B8%89%E5%A4%A7%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%E4%B9%8BBullet/"/>
    <id>https://xtom0369.github.io/2021/10/28/%E4%B8%89%E5%A4%A7%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%E4%B9%8BBullet/</id>
    <published>2021-10-28T14:38:04.000Z</published>
    <updated>2021-11-07T14:32:18.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a><font color="#64EBC1">Why</font></h2><h3 id="为什么要引入物理引擎？"><a href="#为什么要引入物理引擎？" class="headerlink" title="为什么要引入物理引擎？"></a>为什么要引入物理引擎？</h3><p>常见的需求是<font color="#F46224">网络同步</font>。</p><p>当下通用的网络同步方案有<font color="#F46224">帧同步</font>和<font color="#F46224">状态同步</font>。状态同步自然是要在服务器跑物理，帧同步本来可以只跑客户端，服务器只负责转发命令（事实上我们上一个帧同步游戏也是这么做的），但是存在两个问题，一是不同平台存在不同步的可能，因为引擎的物理引擎存在浮点运算，不同平台可能运算结果不一致（这个问题我们使用了截断三位小数后面的方法，不同步出现的概率大大地降低了）；二是只跑客户端无法较好地做校验或者防作弊。</p><span id="more"></span><h3 id="为什么是Bullet？"><a href="#为什么是Bullet？" class="headerlink" title="为什么是Bullet？"></a>为什么是Bullet？</h3><p>主要是项目接入的是Bullet，有一定的使用经验，另外Bullet的优点是项目结构相对简单，接入方便。当然Unity用的是<a href="https://developer.nvidia.com/physx-sdk">PhyX</a>，后续有机会也会开PhyX的坑。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a><font color="#64EBC1">What</font></h2><h3 id="学习Bullet的什么？"><a href="#学习Bullet的什么？" class="headerlink" title="学习Bullet的什么？"></a>学习Bullet的什么？</h3><ol><li><p>通用形状的碰撞体实现</p></li><li><p>碰撞检测实现</p></li><li><p>刚体实现</p></li><li><p>柔体实现</p></li><li><p>IK实现</p></li><li><p>优化手段</p><p> ……</p></li></ol><h2 id="How"><a href="#How" class="headerlink" title="How"></a><font color="#64EBC1">How</font></h2><h3 id="如何进行Bullet学习？"><a href="#如何进行Bullet学习？" class="headerlink" title="如何进行Bullet学习？"></a>如何进行Bullet学习？</h3><ol><li>文档和资料</li></ol><ul><li><p><a href="https://github.com/bulletphysics/bullet3/blob/master/docs/BulletQuickstart.pdf">快速使用文档</a></p></li><li><p><a href="https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf">用户手册</a> </p><ul><li><a href="/2021/10/31/Bullet%E6%96%87%E6%A1%A3%E4%B9%8B%E3%80%8ABullet-User-Manual%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="《Bullet-User-Manual》阅读笔记">《Bullet-User-Manual》阅读笔记</a></li></ul></li></ul><ol start="2"><li>Demo</li></ol><ul><li><p><a href="https://assetstore.unity.com/packages/tools/physics/bullet-physics-for-unity-62991?locale=zh-CN">BulletPhysicsForUnity</a></p><p>这是一个Unity版的Bullet插件，有<a href="https://github.com/Phong13/BulletSharpUnity3d">github</a>版本，插件里将大量的C++接口暴露到了C#层，所以可以学到很多Bullet的概念，以及基础功能的实现。另外里面的bullet的dll是使用另一个github工程<a href="https://github.com/Phong13/BulletSharpPInvoke">BulletSharpPInvoke</a>编译出来的，更底层的代码还是得看编译工程。</p><ul><li><a href="/2021/10/31/BulletPhysicsForUnity%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85/" title="下载和安装">下载和安装</a></li></ul></li></ul><ul><li><p><a href="https://github.com/bulletphysics/bullet3">bullet3</a></p><p>bullet的github仓库，根据教程编译出vs工程，设置启动项目，运行VS即可看到demo工程。</p><p><img src="/2021/10/28/%E4%B8%89%E5%A4%A7%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%E4%B9%8BBullet/Demo.png"></p></li></ul><ol start="3"><li>源码</li></ol><ul><li><p><a href="https://github.com/bulletphysics/bullet3">bullet3</a></p><p>撸完1和2，对bullet的使用也大概有个底了，就可以直接撸源码了。</p></li></ul><ol start="4"><li>参考资料</li></ol><ul><li><a href="https://www.cnblogs.com/liangliangh/p/3576353.html">https://www.cnblogs.com/liangliangh/p/3576353.html</a></li></ul><p>未完待续 …</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#64EBC1&quot;&gt;Why&lt;/font&gt;&lt;/h2&gt;&lt;h3 id=&quot;为什么要引入物理引擎？&quot;&gt;&lt;a href=&quot;#为什么要引入物理引擎？&quot; class=&quot;headerlink&quot; title=&quot;为什么要引入物理引擎？&quot;&gt;&lt;/a&gt;为什么要引入物理引擎？&lt;/h3&gt;&lt;p&gt;常见的需求是&lt;font color=&quot;#F46224&quot;&gt;网络同步&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;当下通用的网络同步方案有&lt;font color=&quot;#F46224&quot;&gt;帧同步&lt;/font&gt;和&lt;font color=&quot;#F46224&quot;&gt;状态同步&lt;/font&gt;。状态同步自然是要在服务器跑物理，帧同步本来可以只跑客户端，服务器只负责转发命令（事实上我们上一个帧同步游戏也是这么做的），但是存在两个问题，一是不同平台存在不同步的可能，因为引擎的物理引擎存在浮点运算，不同平台可能运算结果不一致（这个问题我们使用了截断三位小数后面的方法，不同步出现的概率大大地降低了）；二是只跑客户端无法较好地做校验或者防作弊。&lt;/p&gt;</summary>
    
    
    
    <category term="Physics" scheme="https://xtom0369.github.io/categories/Physics/"/>
    
    <category term="Unity" scheme="https://xtom0369.github.io/categories/Physics/Unity/"/>
    
    
    <category term="Bullet Physics" scheme="https://xtom0369.github.io/tags/Bullet-Physics/"/>
    
    <category term="Physics" scheme="https://xtom0369.github.io/tags/Physics/"/>
    
    <category term="Unity" scheme="https://xtom0369.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Trigger的特点</title>
    <link href="https://xtom0369.github.io/2021/10/26/Trigger%E7%9A%84%E7%89%B9%E7%82%B9/"/>
    <id>https://xtom0369.github.io/2021/10/26/Trigger%E7%9A%84%E7%89%B9%E7%82%B9/</id>
    <published>2021-10-26T15:23:44.000Z</published>
    <updated>2021-10-28T02:38:04.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trigger的特点"><a href="#Trigger的特点" class="headerlink" title="Trigger的特点"></a>Trigger的特点</h2><p>众所周知，Animator的Trigger和Bool的区别是，Trigger是一次性触发判断，触发后会自动重置，而Bool是持久性变量，所以使用Trigger图的就是自动重置的功能。</p><span id="more"></span><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>举个简单的例子，这是一个宝箱的Animator</p><p><img src="/2021/10/26/Trigger%E7%9A%84%E7%89%B9%E7%82%B9/1.png" alt="简单例子"></p><p>例子中的Animator初始状态为<strong>idle</strong>，设置触发器<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Open</strong></font></span>则跳转到状态<strong>open</strong>，设置触发器<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Idle</strong></font></span>则跳转到状态<strong>Idle</strong>。</p><p>由于Trigger是<strong>消耗型</strong>参数，所以参数只有在使用后才会发生重置。所以以下的两种写法最后都会得到相同的结果。</p><ul><li>写法一</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animator.SetTrigger(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">animator.SetTrigger(<span class="string">&quot;Idle&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>写法二</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animator.SetTrigger(<span class="string">&quot;Idle&quot;</span>);</span><br><span class="line">animator.SetTrigger(<span class="string">&quot;Open&quot;</span>);</span><br></pre></td></tr></table></figure><p>原因是方法二设置<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Idle</strong></font></span>触发器后并没有发生消耗，等到切换到open状态后才开始判断，消耗<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Idle</strong></font></span>触发器，跳转到<strong>idle</strong>状态，得到和方法一一致的效果。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trigger的特点&quot;&gt;&lt;a href=&quot;#Trigger的特点&quot; class=&quot;headerlink&quot; title=&quot;Trigger的特点&quot;&gt;&lt;/a&gt;Trigger的特点&lt;/h2&gt;&lt;p&gt;众所周知，Animator的Trigger和Bool的区别是，Trigger是一次性触发判断，触发后会自动重置，而Bool是持久性变量，所以使用Trigger图的就是自动重置的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/categories/Unity/"/>
    
    <category term="Animator" scheme="https://xtom0369.github.io/categories/Unity/Animator/"/>
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/tags/Unity/"/>
    
    <category term="Animator" scheme="https://xtom0369.github.io/tags/Animator/"/>
    
    <category term="Trigger" scheme="https://xtom0369.github.io/tags/Trigger/"/>
    
  </entry>
  
  <entry>
    <title>开发装机环境</title>
    <link href="https://xtom0369.github.io/2021/10/19/%E5%BC%80%E5%8F%91%E8%A3%85%E6%9C%BA%E7%8E%AF%E5%A2%83/"/>
    <id>https://xtom0369.github.io/2021/10/19/%E5%BC%80%E5%8F%91%E8%A3%85%E6%9C%BA%E7%8E%AF%E5%A2%83/</id>
    <published>2021-10-19T05:18:34.000Z</published>
    <updated>2021-10-28T14:28:03.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a><font color="#64EBC1">Why</font></h2><p>写这样一个文档是因为电脑总会因为某些问题而面临重新安装开发环境，包括但不限于</p><ul><li>购置新机器</li><li>重装系统</li></ul><p>有些所以需要记录下重装所需安装的软件和环境的设置。</p><p>记录的内容主要是网址，部分没有官网的会以网盘的方式分享。考虑过都保存软件，但是可能会导致安装后的二次更新问题，维护成本也是个问题，所以还是选择网址。</p><p>以下的记录只针对windows。另外我在想，是不是可以做个脚本一键装机？文章将持续更新</p><span id="more"></span><h2 id="What"><a href="#What" class="headerlink" title="What"></a><font color="#64EBC1">What</font></h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><strong>引擎</strong></p><ul><li><p><a href="https://unity.cn/releases/full/2021">Unity</a></p></li><li><p><a href="https://developer.android.com/studio">Android Studio</a> </p></li><li><p><a href="https://developer.apple.com/xcode/resources/">Xcode</a> </p></li><li><p><a href="https://www.fairygui.com/">FairyGUI</a> （UI引擎）</p></li></ul><p><strong>IDE</strong></p><ul><li><p><a href="https://visualstudio.microsoft.com/zh-hans/vs/">Visual Studio</a>（主力IDE，<font color="#ff0000"><strong>Unity+VS这两兄弟分分钟吃光你的内存，特别是当unity工程较大时，内存最好有24~32g</strong></font>，当然现在也有人开始迁往Rider）</p></li><li><p><a href="https://code.visualstudio.com/?wt.mc_id=vscom_downloads">Visual Studio Code</a></p></li><li><p><a href="https://www.sublimetext.com/3">Sublime3</a> </p></li></ul><p><strong>Tools</strong></p><ul><li><p><a href="https://cmake.org/download/">Cmake</a>（起初是用来编译C++库，后面还用来做C#编dll）</p></li><li><p><a href="https://desktop.github.com/">Github Desktop</a></p></li><li><p><a href="https://git-scm.com/downloads">Git</a>（git命令行）</p></li><li><p><a href="https://tortoisegit.org/download/">TortoiseGit</a>（svn切换到git推荐，操作很接近，当然这两个工具的核心还是在于协作思想的不同）</p></li><li><p><a href="https://tortoisesvn.net/downloads.zh.html">TortoiseSVN</a></p></li></ul><h3 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h3><p><strong>效率</strong></p><ul><li><p><a href="https://dida365.com/about/download">滴答清单</a>（会员有日周月的时间线功能）</p></li><li><p><a href="https://www.notion.so/desktop">Notion</a>（知识体系整理）</p></li><li><p><a href="https://www.listary.com/download">listary</a>（从策划那里“偷”来的工具，主要用来快速索引文件，比如配置表）</p></li><li><p><a href="https://cidian.youdao.com/index.html">有道词典</a></p></li></ul><p><strong>浏览器</strong></p><ul><li><p><a href="https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7B77CCCA8B-F59C-E570-E701-E2575690F29C%7D%26lang%3Dzh-CN%26browser%3D3%26usagestats%3D0%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers%26ap%3Dx64-stable-statsdef_1%26installdataindex%3Dempty/chrome/install/ChromeStandaloneSetup64.exe">Chrome</a></p><ul><li><p><a href="https://chrome.google.com/webstore/detail/sslspeedy/lmdbclggelcpbeoamojllkghfalbjeja">Chrome插件-sslspeedy</a>（vpn工具，需要配合<a href="https://1937o.com/main.php">vpnso账户</a>）</p></li><li><p><a href="https://chrome.google.com/webstore/detail/chrono-download-manager/mciiogijehkdemklbdcbfkefimifhecn?utm_source=chrome-ntp-icon">Chrome插件-下载管理器</a>（自带的没有断点续传功能）  </p></li><li><p><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb?utm_source=chrome-ntp-icon">Chrome插件-google翻译</a></p></li></ul></li></ul><p><strong>VPN</strong></p><ul><li><p><a href="https://1937o.com/main.php">vpnso</a>（vpn网站，用了6年了，稳定性高，看了下最新私人账号一年200，我买的时候100，后面续费也都是100，很良心，浏览网页看视频操作github仓库都问题不大。支持windows/chrome插件/android/ios）</p></li><li><p><a href="https://openvpn.net/community-downloads/">openvpn</a>（这个主要用来利用vpn远程办公，但是需要自己搭载环境，效果类似于向日葵Teamviewer等，但是不会被限速！同理也可以在家搭建NAS+DDNS，相当于一个家庭网盘，可在任何一个有网络的地方取用家里的资料，同样不会被限速，且资料安全，当然最好再自己搞下自动备份。）</p></li></ul><p><strong>娱乐</strong></p><ul><li><p><a href="http://v.qq.com/download.html">腾讯视频</a>（豆瓣高分电影多）</p></li><li><p><a href="https://pd.youku.com/pc?spm=a2hpd.20022520.carousel.3!3~A">优酷视频</a>（TVB铁粉必备，但是现在的TVB是越来越没内味了）</p></li><li><p><a href="https://y.qq.com/download/download.html">QQ音乐</a></p></li><li><p><a href="https://music.163.com/#/download">网易云音乐</a></p></li></ul><p><strong>社交</strong></p><ul><li><p><a href="https://tim.qq.com/download.html">TIM</a></p></li><li><p><a href="https://windows.weixin.qq.com/?lang=zh_CN">Wechat</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#64EBC1&quot;&gt;Why&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;写这样一个文档是因为电脑总会因为某些问题而面临重新安装开发环境，包括但不限于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;购置新机器&lt;/li&gt;
&lt;li&gt;重装系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有些所以需要记录下重装所需安装的软件和环境的设置。&lt;/p&gt;
&lt;p&gt;记录的内容主要是网址，部分没有官网的会以网盘的方式分享。考虑过都保存软件，但是可能会导致安装后的二次更新问题，维护成本也是个问题，所以还是选择网址。&lt;/p&gt;
&lt;p&gt;以下的记录只针对windows。另外我在想，是不是可以做个脚本一键装机？文章将持续更新&lt;/p&gt;</summary>
    
    
    
    
    <category term="装机" scheme="https://xtom0369.github.io/tags/%E8%A3%85%E6%9C%BA/"/>
    
    <category term="开发环境" scheme="https://xtom0369.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
</feed>
