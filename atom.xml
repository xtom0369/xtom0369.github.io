<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xtom&#39;s blog</title>
  
  
  <link href="https://xtom0369.github.io/atom.xml" rel="self"/>
  
  <link href="https://xtom0369.github.io/"/>
  <updated>2021-10-30T15:35:15.601Z</updated>
  <id>https://xtom0369.github.io/</id>
  
  <author>
    <name>xtom</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>入坑BulletPhysics</title>
    <link href="https://xtom0369.github.io/2021/10/28/%E5%85%A5%E5%9D%91BulletPhysics/"/>
    <id>https://xtom0369.github.io/2021/10/28/%E5%85%A5%E5%9D%91BulletPhysics/</id>
    <published>2021-10-28T14:38:04.000Z</published>
    <updated>2021-10-30T15:35:15.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a><font color="#64EBC1">Why</font></h2><h3 id="为什么要引入物理引擎？"><a href="#为什么要引入物理引擎？" class="headerlink" title="为什么要引入物理引擎？"></a>为什么要引入物理引擎？</h3><p>常见的需求是<strong>网络同步</strong>。</p><p>当下通用的网络同步方案有<strong>帧同步</strong>和<strong>状态同步</strong>。状态同步自然是要在服务器跑物理，帧同步本来可以只跑客户端，服务器只负责转发命令（事实上我们上一个帧同步游戏也是这么做的），但是存在两个问题，一是不同平台存在不同步的可能，因为引擎的物理引擎存在浮点运算，不同平台可能运算结果不一致（这个问题我们使用了截断三位小数后面的方法，不同步出现的概率大大地降低了）；二是只跑客户端无法较好地做校验或者防作弊。</p><span id="more"></span><h3 id="为什么是Bullet？"><a href="#为什么是Bullet？" class="headerlink" title="为什么是Bullet？"></a>为什么是Bullet？</h3><p>主要是项目接入的是Bullet，有一定的使用经验，另外Bullet的优点是项目结构相对简单，接入方便。当然unity用的是<a href="https://developer.nvidia.com/physx-sdk">PhyX</a>，后续有机会也会开PhyX的坑。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a><font color="#64EBC1">What</font></h2><h3 id="学习Bullet的什么？"><a href="#学习Bullet的什么？" class="headerlink" title="学习Bullet的什么？"></a>学习Bullet的什么？</h3><ol><li><p>通用形状的碰撞体实现</p></li><li><p>碰撞检测实现</p></li><li><p>刚体实现</p></li><li><p>柔体实现</p></li><li><p>IK实现</p></li><li><p>优化手段</p><p> ……</p></li></ol><h2 id="How"><a href="#How" class="headerlink" title="How"></a><font color="#64EBC1">How</font></h2><ol><li>文档和资料</li></ol><ul><li><p><a href="https://github.com/bulletphysics/bullet3/blob/master/docs/BulletQuickstart.pdf">快速使用文档</a></p></li><li><p><a href="https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf">用户手册</a> </p></li></ul><ol start="2"><li>Demo</li></ol><ul><li><p><a href="https://assetstore.unity.com/packages/tools/physics/bullet-physics-for-unity-62991?locale=zh-CN">BulletPhysicsForUnity</a></p><p>这是一个Unity版的Bullet插件，有<a href="https://github.com/Phong13/BulletSharpUnity3d">github</a>版本，插件里将大量的C++接口暴露到了C#层，所以可以学到很多Bullet的概念，以及基础功能的实现。另外里面的bullet的dll是使用另一个github工程<a href="https://github.com/Phong13/BulletSharpPInvoke">BulletSharpPInvoke</a>编译出来的，更底层的代码还是得看编译工程。</p></li><li><p><a href="https://github.com/bulletphysics/bullet3">bullet3</a></p><p>bullet的github仓库，根据教程编译出vs工程，设置启动项目，运行VS即可看到demo工程。</p><p><img src="/2021/10/28/%E5%85%A5%E5%9D%91BulletPhysics/Demo.png"></p></li></ul><ol start="3"><li>源码</li></ol><ul><li><p><a href="https://github.com/bulletphysics/bullet3">bullet3</a></p><p>撸完1和2，对bullet的使用也大概有个底了，就可以直接撸源码了。</p></li></ul><pre><code>未完待续 ...</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#64EBC1&quot;&gt;Why&lt;/font&gt;&lt;/h2&gt;&lt;h3 id=&quot;为什么要引入物理引擎？&quot;&gt;&lt;a href=&quot;#为什么要引入物理引擎？&quot; class=&quot;headerlink&quot; title=&quot;为什么要引入物理引擎？&quot;&gt;&lt;/a&gt;为什么要引入物理引擎？&lt;/h3&gt;&lt;p&gt;常见的需求是&lt;strong&gt;网络同步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当下通用的网络同步方案有&lt;strong&gt;帧同步&lt;/strong&gt;和&lt;strong&gt;状态同步&lt;/strong&gt;。状态同步自然是要在服务器跑物理，帧同步本来可以只跑客户端，服务器只负责转发命令（事实上我们上一个帧同步游戏也是这么做的），但是存在两个问题，一是不同平台存在不同步的可能，因为引擎的物理引擎存在浮点运算，不同平台可能运算结果不一致（这个问题我们使用了截断三位小数后面的方法，不同步出现的概率大大地降低了）；二是只跑客户端无法较好地做校验或者防作弊。&lt;/p&gt;</summary>
    
    
    
    <category term="physics" scheme="https://xtom0369.github.io/categories/physics/"/>
    
    <category term="unity" scheme="https://xtom0369.github.io/categories/physics/unity/"/>
    
    
    <category term="bullet physics" scheme="https://xtom0369.github.io/tags/bullet-physics/"/>
    
    <category term="physics" scheme="https://xtom0369.github.io/tags/physics/"/>
    
    <category term="unity" scheme="https://xtom0369.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Trigger的特点</title>
    <link href="https://xtom0369.github.io/2021/10/26/Trigger%E7%9A%84%E7%89%B9%E7%82%B9/"/>
    <id>https://xtom0369.github.io/2021/10/26/Trigger%E7%9A%84%E7%89%B9%E7%82%B9/</id>
    <published>2021-10-26T15:23:44.000Z</published>
    <updated>2021-10-28T02:38:04.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trigger的特点"><a href="#Trigger的特点" class="headerlink" title="Trigger的特点"></a>Trigger的特点</h2><p>众所周知，Animator的Trigger和Bool的区别是，Trigger是一次性触发判断，触发后会自动重置，而Bool是持久性变量，所以使用Trigger图的就是自动重置的功能。</p><span id="more"></span><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>举个简单的例子，这是一个宝箱的Animator</p><p><img src="/2021/10/26/Trigger%E7%9A%84%E7%89%B9%E7%82%B9/1.png" alt="简单例子"></p><p>例子中的Animator初始状态为<strong>idle</strong>，设置触发器<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Open</strong></font></span>则跳转到状态<strong>open</strong>，设置触发器<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Idle</strong></font></span>则跳转到状态<strong>Idle</strong>。</p><p>由于Trigger是<strong>消耗型</strong>参数，所以参数只有在使用后才会发生重置。所以以下的两种写法最后都会得到相同的结果。</p><ul><li>写法一</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animator.SetTrigger(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">animator.SetTrigger(<span class="string">&quot;Idle&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>写法二</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animator.SetTrigger(<span class="string">&quot;Idle&quot;</span>);</span><br><span class="line">animator.SetTrigger(<span class="string">&quot;Open&quot;</span>);</span><br></pre></td></tr></table></figure><p>原因是方法二设置<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Idle</strong></font></span>触发器后并没有发生消耗，等到切换到open状态后才开始判断，消耗<span style="background-color: #F9F2F4;"><font color="#CE3858"><strong>Idle</strong></font></span>触发器，跳转到<strong>idle</strong>状态，得到和方法一一致的效果。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Trigger的特点&quot;&gt;&lt;a href=&quot;#Trigger的特点&quot; class=&quot;headerlink&quot; title=&quot;Trigger的特点&quot;&gt;&lt;/a&gt;Trigger的特点&lt;/h2&gt;&lt;p&gt;众所周知，Animator的Trigger和Bool的区别是，Trigger是一次性触发判断，触发后会自动重置，而Bool是持久性变量，所以使用Trigger图的就是自动重置的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/categories/Unity/"/>
    
    <category term="Animator" scheme="https://xtom0369.github.io/categories/Unity/Animator/"/>
    
    
    <category term="Unity" scheme="https://xtom0369.github.io/tags/Unity/"/>
    
    <category term="Animator" scheme="https://xtom0369.github.io/tags/Animator/"/>
    
    <category term="Trigger" scheme="https://xtom0369.github.io/tags/Trigger/"/>
    
  </entry>
  
  <entry>
    <title>开发装机环境</title>
    <link href="https://xtom0369.github.io/2021/10/19/%E5%BC%80%E5%8F%91%E8%A3%85%E6%9C%BA%E7%8E%AF%E5%A2%83/"/>
    <id>https://xtom0369.github.io/2021/10/19/%E5%BC%80%E5%8F%91%E8%A3%85%E6%9C%BA%E7%8E%AF%E5%A2%83/</id>
    <published>2021-10-19T05:18:34.000Z</published>
    <updated>2021-10-28T14:28:03.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a><font color="#64EBC1">Why</font></h2><p>写这样一个文档是因为电脑总会因为某些问题而面临重新安装开发环境，包括但不限于</p><ul><li>购置新机器</li><li>重装系统</li></ul><p>有些所以需要记录下重装所需安装的软件和环境的设置。</p><p>记录的内容主要是网址，部分没有官网的会以网盘的方式分享。考虑过都保存软件，但是可能会导致安装后的二次更新问题，维护成本也是个问题，所以还是选择网址。</p><p>以下的记录只针对windows。另外我在想，是不是可以做个脚本一键装机？文章将持续更新</p><span id="more"></span><h2 id="What"><a href="#What" class="headerlink" title="What"></a><font color="#64EBC1">What</font></h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><strong>引擎</strong></p><ul><li><p><a href="https://unity.cn/releases/full/2021">Unity</a></p></li><li><p><a href="https://developer.android.com/studio">Android Studio</a> </p></li><li><p><a href="https://developer.apple.com/xcode/resources/">Xcode</a> </p></li><li><p><a href="https://www.fairygui.com/">FairyGUI</a> （UI引擎）</p></li></ul><p><strong>IDE</strong></p><ul><li><p><a href="https://visualstudio.microsoft.com/zh-hans/vs/">Visual Studio</a>（主力IDE，<font color="#ff0000"><strong>Unity+VS这两兄弟分分钟吃光你的内存，特别是当unity工程较大时，内存最好有24~32g</strong></font>，当然现在也有人开始迁往Rider）</p></li><li><p><a href="https://code.visualstudio.com/?wt.mc_id=vscom_downloads">Visual Studio Code</a></p></li><li><p><a href="https://www.sublimetext.com/3">Sublime3</a> </p></li></ul><p><strong>Tools</strong></p><ul><li><p><a href="https://cmake.org/download/">Cmake</a>（起初是用来编译C++库，后面还用来做C#编dll）</p></li><li><p><a href="https://desktop.github.com/">Github Desktop</a></p></li><li><p><a href="https://git-scm.com/downloads">Git</a>（git命令行）</p></li><li><p><a href="https://tortoisegit.org/download/">TortoiseGit</a>（svn切换到git推荐，操作很接近，当然这两个工具的核心还是在于协作思想的不同）</p></li><li><p><a href="https://tortoisesvn.net/downloads.zh.html">TortoiseSVN</a></p></li></ul><h3 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h3><p><strong>效率</strong></p><ul><li><p><a href="https://dida365.com/about/download">滴答清单</a>（会员有日周月的时间线功能）</p></li><li><p><a href="https://www.notion.so/desktop">Notion</a>（知识体系整理）</p></li><li><p><a href="https://www.listary.com/download">listary</a>（从策划那里“偷”来的工具，主要用来快速索引文件，比如配置表）</p></li><li><p><a href="https://cidian.youdao.com/index.html">有道词典</a></p></li></ul><p><strong>浏览器</strong></p><ul><li><p><a href="https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7B77CCCA8B-F59C-E570-E701-E2575690F29C%7D%26lang%3Dzh-CN%26browser%3D3%26usagestats%3D0%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers%26ap%3Dx64-stable-statsdef_1%26installdataindex%3Dempty/chrome/install/ChromeStandaloneSetup64.exe">Chrome</a></p><ul><li><p><a href="https://chrome.google.com/webstore/detail/sslspeedy/lmdbclggelcpbeoamojllkghfalbjeja">Chrome插件-sslspeedy</a>（vpn工具，需要配合<a href="https://1937o.com/main.php">vpnso账户</a>）</p></li><li><p><a href="https://chrome.google.com/webstore/detail/chrono-download-manager/mciiogijehkdemklbdcbfkefimifhecn?utm_source=chrome-ntp-icon">Chrome插件-下载管理器</a>（自带的没有断点续传功能）  </p></li><li><p><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb?utm_source=chrome-ntp-icon">Chrome插件-google翻译</a></p></li></ul></li></ul><p><strong>VPN</strong></p><ul><li><p><a href="https://1937o.com/main.php">vpnso</a>（vpn网站，用了6年了，稳定性高，看了下最新私人账号一年200，我买的时候100，后面续费也都是100，很良心，浏览网页看视频操作github仓库都问题不大。支持windows/chrome插件/android/ios）</p></li><li><p><a href="https://openvpn.net/community-downloads/">openvpn</a>（这个主要用来利用vpn远程办公，但是需要自己搭载环境，效果类似于向日葵Teamviewer等，但是不会被限速！同理也可以在家搭建NAS+DDNS，相当于一个家庭网盘，可在任何一个有网络的地方取用家里的资料，同样不会被限速，且资料安全，当然最好再自己搞下自动备份。）</p></li></ul><p><strong>娱乐</strong></p><ul><li><p><a href="http://v.qq.com/download.html">腾讯视频</a>（豆瓣高分电影多）</p></li><li><p><a href="https://pd.youku.com/pc?spm=a2hpd.20022520.carousel.3!3~A">优酷视频</a>（TVB铁粉必备，但是现在的TVB是越来越没内味了）</p></li><li><p><a href="https://y.qq.com/download/download.html">QQ音乐</a></p></li><li><p><a href="https://music.163.com/#/download">网易云音乐</a></p></li></ul><p><strong>社交</strong></p><ul><li><p><a href="https://tim.qq.com/download.html">TIM</a></p></li><li><p><a href="https://windows.weixin.qq.com/?lang=zh_CN">Wechat</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#64EBC1&quot;&gt;Why&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;写这样一个文档是因为电脑总会因为某些问题而面临重新安装开发环境，包括但不限于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;购置新机器&lt;/li&gt;
&lt;li&gt;重装系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有些所以需要记录下重装所需安装的软件和环境的设置。&lt;/p&gt;
&lt;p&gt;记录的内容主要是网址，部分没有官网的会以网盘的方式分享。考虑过都保存软件，但是可能会导致安装后的二次更新问题，维护成本也是个问题，所以还是选择网址。&lt;/p&gt;
&lt;p&gt;以下的记录只针对windows。另外我在想，是不是可以做个脚本一键装机？文章将持续更新&lt;/p&gt;</summary>
    
    
    
    
    <category term="装机" scheme="https://xtom0369.github.io/tags/%E8%A3%85%E6%9C%BA/"/>
    
    <category term="开发环境" scheme="https://xtom0369.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
</feed>
